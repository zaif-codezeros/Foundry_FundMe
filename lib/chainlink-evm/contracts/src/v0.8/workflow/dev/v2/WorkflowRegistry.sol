// SPDX-License-Identifier: BUSL 1.1
pragma solidity 0.8.26;

import {ITypeAndVersion} from "../../../shared/interfaces/ITypeAndVersion.sol";

import {Ownable2StepMsgSender} from "../../../shared/access/Ownable2StepMsgSender.sol";

import {ECDSA} from "@openzeppelin/contracts@5.1.0/utils/cryptography/ECDSA.sol";
import {MessageHashUtils} from "@openzeppelin/contracts@5.1.0/utils/cryptography/MessageHashUtils.sol";
import {EnumerableMap} from "@openzeppelin/contracts@5.1.0/utils/structs/EnumerableMap.sol";
import {EnumerableSet} from "@openzeppelin/contracts@5.1.0/utils/structs/EnumerableSet.sol";

// solhint-disable-next-line max-states-count
contract WorkflowRegistry is Ownable2StepMsgSender, ITypeAndVersion {
  using EnumerableSet for EnumerableSet.Bytes32Set;
  using EnumerableSet for EnumerableSet.AddressSet;
  using EnumerableMap for EnumerableMap.AddressToBytes32Map;

  string public constant override typeAndVersion = "WorkflowRegistry 2.0.0-dev";

  /// @dev The set of allowed signers for ownership proofs. These signers are considered to be trusted entities.
  /// If the ownership proof is not signed by one of the allowed signers, signature will be rejected.
  mapping(address signer => bool allowed) private s_allowedSigners;
  /// @dev The set of linked owners. These are the addresses that have successfully linked their ownership proofs.
  /// Ownership proofs are signed messages generated by a trusted entity, with each proof being unique for each owner
  /// address. The owner address is embedded into the proof itself together with other relevant metadata that uniquely
  /// represents an off-chain account.
  /// Fundamental assumption is that only a person (or a group of people) who has access both to the private key of the owner
  /// address and to the off-chain account, may be able to generate a valid signature signed by the trusted entity. Once this
  /// valid signature is submitted to this contract, it can be verified and used to link or unlink the owner address.
  EnumerableMap.AddressToBytes32Map private s_linkedOwners;
  /// @dev This is a mapping of ownership proofs indicating whether the proof has been previously used or not. This is used
  /// to prevent someone from re-using the same proof for linking more than once, and ensures that each proof is unique per
  /// single linking request, not matter if it originates from the same owner address or not. This allows us to verifiably
  /// enforce an invariant on proofs.
  mapping(bytes32 proof => bool used) private s_usedProofs;

  /// @dev workflowRid (reference ID) is a hash of (owner ∥ name ∥ label). It functions as the primary index for the workflow storage.
  mapping(bytes32 workflowRid => WorkflowMetadata workflowMetadata) private s_workflows;
  /// @dev workflowKey is a hash of (owner ∥ name ) and maps to a set of Rids. It is used for filtering workflows based on just
  /// the name, as there may be multiple workflows with the same name under a different tag.
  mapping(bytes32 workflowKey => EnumerableSet.Bytes32Set) private s_workflowKeyToRids;
  /// @dev workflowId ⇒ workflowRid. This mapping lets us enforce global uniqueness of workflowId while also allows us to lookup
  /// workflows through the workflowId.
  mapping(bytes32 workflowId => bytes32 workflowRid) private s_idToRid;

  // Secondary indices for iteration / queries
  mapping(address owner => EnumerableSet.Bytes32Set workflowRids) private s_activeOwnerWorkflowRids; // owner -> workflowRid set
  mapping(bytes32 donHash => EnumerableSet.Bytes32Set workflowRids) private s_activeDONWorkflowRids; // donHash -> workflowRid set

  /// @dev Every workflow ever registered under `donFamily` as donHash. Pruned only on delete.
  mapping(bytes32 donHash => EnumerableSet.Bytes32Set workflowRids) private s_allDONRids;
  /// @dev Every workflow ever registered for an owner. Pruned only on delete.
  mapping(address owner => EnumerableSet.Bytes32Set workflowRids) private s_allOwnerRids;
  mapping(bytes32 workflowKey => EnumerableSet.Bytes32Set activeRids) private s_activeRidsByWorkflowKey; // workflowKey → active Rids
  // Fast counters for limits enforcement
  mapping(address owner => mapping(bytes32 donHash => uint32 workflowCount)) private s_userDONCount; // owner -> (donHash -> #workflows)
  // The don family (as a hash) that the workflow is assigned to. Only active workflows are assigned don families.
  // When a workflow is paused it is removed from the don family.
  mapping(bytes32 rid => bytes32 donHash) private s_donByWorkflowRid;

  // ================================================================
  // |                         Events                               |
  // ================================================================

  event AllowedSignersUpdated(address[] signers, bool allowed);
  event OwnershipLinkUpdated(address indexed owner, bytes32 indexed proof, bool indexed added);
  event DONLimitSet(string donFamily, uint32 limit);
  event UserDONLimitSet(address indexed user, string donFamily, uint32 limit);
  event UserDONLimitUnset(address indexed user, string donFamily);
  event WorkflowRegistered(
    bytes32 indexed workflowId, address indexed owner, string donFamily, WorkflowStatus status, string workflowName
  );
  event WorkflowUpdated(
    bytes32 indexed oldWorkflowId,
    bytes32 indexed newWorkflowId,
    address indexed owner,
    string donFamily,
    string workflowName
  );
  event WorkflowPaused(bytes32 indexed workflowId, address indexed owner, string donFamily, string workflowName);
  event WorkflowActivated(bytes32 indexed workflowId, address indexed owner, string donFamily, string workflowName);
  event WorkflowDeleted(bytes32 indexed workflowId, address indexed owner, string donFamily, string workflowName);
  /// @dev Fired whenever a workflow’s DON label is changed
  event WorkflowDonFamilyUpdated(
    bytes32 indexed workflowId, address indexed owner, string oldDonFamily, string newDonFamily
  );

  // ================================================================
  // |                         Errors                               |
  // ================================================================

  error ZeroAddressNotAllowed();
  error ZeroWorkflowIDNotAllowed();
  error LinkOwnerRequestExpired(address caller, uint256 currentTime, uint256 expiryTimestamp);
  error UnlinkOwnerRequestExpired(address caller, uint256 currentTime, uint256 expiryTimestamp);
  error OwnershipLinkAlreadyExists(address owner);
  error OwnershipLinkDoesNotExist(address owner);
  error InvalidSignature(bytes signature, uint8 recoverErrorId, bytes32 recoverErrorArg);
  error InvalidOwnershipLink(address owner, uint256 validityTimestamp, bytes32 proof, bytes signature);
  error OwnershipProofAlreadyUsed(address caller, bytes32 proof);
  error CannotUnlinkWithActiveWorkflows();
  error CallerIsNotWorkflowOwner(address caller);
  error DonLimitNotSet(string donFamily);
  error MaxWorkflowsPerUserDONExceeded(address owner, string donFamily);
  error UserDONOverrideExceedsDONLimit();
  error URLTooLong(uint256 provided, uint8 maxAllowed);
  error WorkflowDoesNotExist();
  error WorkflowIDAlreadyExists(bytes32 workflowId);
  error WorkflowNameRequired();
  error WorkflowNameTooLong(uint256 provided, uint8 maxAllowed);
  error WorkflowTagRequired();
  error WorkflowTagTooLong(uint256 provided, uint8 maxAllowed);
  error AttributesTooLong(uint256 provided, uint256 maxAllowed);
  error EmptyUpdateBatch();
  error BinaryURLRequired();
  error CannotUpdateDONFamilyForPausedWorkflows();

  // ================================================================
  // |                         Enums                                |
  // ================================================================

  enum WorkflowStatus {
    ACTIVE,
    PAUSED
  }

  enum PreUnlinkAction {
    NONE, //              No action prior to unlinking.
    REMOVE_WORKFLOWS, //  Remove all workflows owned by the owner prior to unlinking.
    PAUSE_WORKFLOWS //    Pause all workflows owned by the owner prior to unlinking.

  }

  enum LinkingRequestType {
    LINK_OWNER, //       Request to link an owner address.
    UNLINK_OWNER //       Request to unlink an owner address.

  }

  struct WorkflowMetadata {
    bytes32 workflowId; //       Unique identifier from hash(owner, workflow name, wasm binary, cfg).
    address owner; // ─────────╮ Workflow owner.
    uint64 createdAt; //       │ block.timestamp when the workflow was first registered.
    WorkflowStatus status; // ─╯ Current status of the workflow (active, paused).
    string workflowName; //      Human readable string (64 chars limit).
    string binaryUrl; //         URL to the wasm binary (200 chars limit).
    string configUrl; //         URL to the config (200 chars limit).
    string tag; //               Unique per (owner, workflowName) human readable identifier (32 chars limit)
    bytes attributes; //         Arbitrary bytes for additional workflow details.
  }

  struct WorkflowMetadataView {
    bytes32 workflowId;
    address owner;
    uint64 createdAt;
    WorkflowStatus status;
    string workflowName;
    string binaryUrl;
    string configUrl;
    string tag;
    bytes attributes;
    string donFamily;
  }

  // ================================================================
  // |                   Workflow Metadata Config                   |
  // ================================================================
  /// @dev Packed metadata length caps (owner-configurable overrides):
  /// We store four independent uint fields — maxNameLen, maxTagLen, maxUrlLen and maxAttrLen — in a single 256-bit word
  /// to save storage. Default values (_DEF_MAX_*) are hard-coded as constants and never consume storage.
  /// Only when an override differs from those defaults do we write one packed word (s_metadataCaps).
  /// Getter functions (maxNameLen(), maxTagLen(), etc.) extract each
  /// field via bit-shifts, falling back to the default if no override is set.
  ///
  /// Pattern inspired by OpenZeppelin’s ERC20Capped and Preset modules:
  /// • Defaults live in bytecode (zero gas on deployment)
  /// • Overrides live in one slot (one SLOAD per read)
  /// • No per-field storage or struct copying required
  uint8 private constant DEFAULT_NAME_LEN = 64;
  uint8 private constant DEFAULT_TAG_LEN = 32;
  uint8 private constant DEFAULT_URL_LEN = 200;
  uint16 private constant DEFAULT_ATTR_LEN = 1024;

  /// @dev Bit-layout (LSB … MSB)
  uint8 private constant NAME_SHIFT = 0; // 8 bits
  uint8 private constant TAG_SHIFT = 8; // 8 bits
  uint8 private constant URL_SHIFT = 16; // 8 bits
  uint8 private constant ATTR_SHIFT = 24; // 16 bits (uint16)

  /// @dev Single-slot override; 0 means “all defaults”.
  uint256 private s_metadataCaps;

  /// @notice Emitted when metadata length limits are updated
  /// @param maxNameLen New cap for `workflowName` length
  /// @param maxTagLen  New cap for `tag` length
  /// @param maxUrlLen  New cap for URL lengths
  /// @param maxAttrLen New cap for `attributes` length
  event MetadataConfigUpdated(uint8 maxNameLen, uint8 maxTagLen, uint8 maxUrlLen, uint16 maxAttrLen);

  /// @notice Owner can override any of the four caps.
  /// Passing the exact default values clears the override slot. Passing all 4 values as 0
  /// will also clear the override back to default. However, setting only some of the values to 0 will remove the cap
  /// and make the cap unlimited only for that field.
  /// @param nameLen New cap for `workflowName` (0 ➜ unlimited)
  /// @param tagLen  New cap for `tag`
  /// @param urlLen  New cap for each URL
  /// @param attrLen New cap for `attributes`
  function setMetadataConfig(uint8 nameLen, uint8 tagLen, uint8 urlLen, uint16 attrLen) external onlyOwner {
    // Pack
    uint256 packed = (uint256(nameLen) << NAME_SHIFT) | (uint256(tagLen) << TAG_SHIFT) | (uint256(urlLen) << URL_SHIFT)
      | (uint256(attrLen) << ATTR_SHIFT);

    // If caller supplied all defaults (or zeros) clear the override slot
    uint256 defaultPacked = (uint256(DEFAULT_NAME_LEN) << NAME_SHIFT) | (uint256(DEFAULT_TAG_LEN) << TAG_SHIFT)
      | (uint256(DEFAULT_URL_LEN) << URL_SHIFT) | (uint256(DEFAULT_ATTR_LEN) << ATTR_SHIFT);

    if (packed == defaultPacked || packed == 0) {
      // if all 0 is passed, the caps are set to contract default
      delete s_metadataCaps;
    } else {
      s_metadataCaps = packed;
    }

    emit MetadataConfigUpdated(nameLen, tagLen, urlLen, attrLen);
  }

  function _caps() private view returns (uint256 c) {
    return s_metadataCaps == 0
      ? (uint256(DEFAULT_NAME_LEN) << NAME_SHIFT) | (uint256(DEFAULT_TAG_LEN) << TAG_SHIFT)
        | (uint256(DEFAULT_URL_LEN) << URL_SHIFT) | (uint256(DEFAULT_ATTR_LEN) << ATTR_SHIFT)
      : s_metadataCaps;
  }

  function maxNameLen() public view returns (uint8) {
    return uint8(_caps() >> NAME_SHIFT);
  }

  function maxTagLen() public view returns (uint8) {
    return uint8(_caps() >> TAG_SHIFT);
  }

  function maxUrlLen() public view returns (uint8) {
    return uint8(_caps() >> URL_SHIFT);
  }

  function maxAttrLen() public view returns (uint16) {
    return uint16(_caps() >> ATTR_SHIFT);
  }

  // ================================================================
  // |                   Workflow Owner Config                      |
  // ================================================================
  /// @dev map each owner address → their arbitrary config. Can be used to control billing parameters
  // or any other data per owner
  mapping(address owner => bytes config) private s_ownerConfig;

  event WorkflowOwnerConfigUpdated(address indexed owner, bytes config);

  /// @notice Let each workflow‐owner store an arbitrary “config blob” (e.g. billing params)
  /// @dev    You can put any encoded data here; off‐chain tools will watch the event or call the getter.
  /// @param  config  ABI‐encoded owner‐specific settings
  function setWorkflowOwnerConfig(address owner, bytes calldata config) external onlyOwner {
    s_ownerConfig[owner] = config;
    emit WorkflowOwnerConfigUpdated(owner, config);
  }

  /// @notice Read back an owner’s last‐saved config blob
  /// @param  owner  The address whose config you want
  /// @return The raw `bytes` they most recently set
  function getWorkflowOwnerConfig(
    address owner
  ) external view returns (bytes memory) {
    return s_ownerConfig[owner];
  }

  // ================================================================
  // |                         DON Config                           |
  // ================================================================
  // Struct to distinguish between unset and explicitly set zero values

  struct ConfigValue {
    uint32 value;
    bool enabled;
  }

  /// @dev Configuration struct for don capacity of active workflows. Paused workflows are ignored.
  ///      One config blob per DON (keyed by _hash(donFamily))
  struct DonConfig {
    /// @dev Human-readable DON label (e.g. “fast-pool”)
    string label;
    /// @dev Global cap for active workflows on this DON
    ConfigValue limitValue;
    /// @dev Optional per-user overrides for this DON
    mapping(address => ConfigValue) userOverride;
  }

  /// @dev All DON configs
  mapping(bytes32 donHash => DonConfig donCfg) private s_donConfigs;

  /// @notice Sets or clears a DON-wide limit for the maximum number of
  ///         ACTIVE workflows.
  /// @dev    Only callable by the contract owner.
  ///         When `enabled` is true, a limit is added for the DON family.
  ///         When `enabled` is false, the existing limit is removed.
  ///         When both adding and removing, an event record is created for the event, and the event itself
  ///         is emited in the internal helper.
  /// @notice Sets or clears the DON-wide limit for active workflows.
  /// @param donFamily Human-readable string DON family
  /// @param limit     New cap (ignored if `enabled==false`)
  /// @param enabled   Flag indicating whether to store (`true`) or delete (`false`)
  function setDONLimit(string calldata donFamily, uint32 limit, bool enabled) external onlyOwner {
    bytes32 donHash = _hash(donFamily);
    uint32 newCapacity = enabled ? limit : 0;
    DonConfig storage cfg = s_donConfigs[donHash];

    if (cfg.limitValue.enabled == enabled && cfg.limitValue.value == newCapacity) {
      return;
    }

    // write the human-readable string only once
    if (bytes(cfg.label).length == 0) {
      cfg.label = donFamily;
    }
    cfg.limitValue.enabled = enabled;
    cfg.limitValue.value = newCapacity;

    s_events.push(
      EventRecord({
        eventType: EventType.DONCapacitySet,
        timestamp: uint32(block.timestamp),
        payload: abi.encode(donHash, newCapacity)
      })
    );

    emit DONLimitSet(donFamily, newCapacity);
  }

  /// @notice Sets or removes a per-user, per-DON limit for ACTIVE workflows.
  /// @dev    Only the contract owner may call this.
  ///         - When `enabled` is true, stores the override and emits `UserDONLimitSet(user, donFamily, limit)`.
  ///         - When `enabled` is false, deletes any override and emits `UserDONLimitUnset(user, donFamily)`.
  ///         - When `enabled` is true and the same limit already exist, it does not write or emit a new event.
  ///         - When `enabled` is false and there is no limit, it does not remove or emit a new event.
  ///         The per-user override `limit` must not exceed the global DON limit, otherwise it reverts.
  ///         When per-user overrides are added or removed, no event record is added because this does not affect the
  ///         actual capacity of the DON as it is already constrained by the DON capacity.
  /// @notice Sets or clears a per‐user override for the maximum active workflows on a given DON
  /// @param user       The address for which to set or clear the override
  /// @param donFamily  The human‐readable DON label (must have been configured via `setDONLimit`)
  /// @param limit      New per‐user cap when `enabled == true`
  /// @param enabled    `true` to enable/update the override; `false` to remove it
  function setUserDONOverride(address user, string calldata donFamily, uint32 limit, bool enabled) external onlyOwner {
    bytes32 donHash = _hash(donFamily);
    DonConfig storage cfg = s_donConfigs[donHash];

    // Ensure the DON itself has a global cap configured
    if (!cfg.limitValue.enabled) {
      revert DonLimitNotSet(donFamily);
    }

    ConfigValue storage ov = cfg.userOverride[user];

    if (enabled) {
      // Must not exceed the global DON cap
      if (limit > cfg.limitValue.value) {
        revert UserDONOverrideExceedsDONLimit();
      }

      if (!ov.enabled) {
        // → was OFF, now turning ON with new cap
        ov.enabled = true;
        ov.value = limit;
        emit UserDONLimitSet(user, donFamily, limit);
      } else if (ov.value != limit) {
        // → was ON with a different cap, so update it
        ov.value = limit;
        emit UserDONLimitSet(user, donFamily, limit);
      } else {
        // → already ON at exactly this cap, nothing to do
        return;
      }
    } else {
      if (!ov.enabled) {
        // → already OFF, nothing to do
        return;
      }
      // → was ON, now turning OFF (and clearing the value)
      ov.enabled = false;
      ov.value = 0;
      emit UserDONLimitUnset(user, donFamily);
    }
  }

  /// @notice Gets the configured maximum number of workflows for a given DON label.
  /// @dev DON labels must first be configured in the Config.donLimit before workflows can be created against them.
  /// @param donFamily The identifier of the DON whose workflow cap is being queried.
  /// @return maxWorkflows The maximum number of workflows allowed for the specified DON, or zero if the DON
  ///                      is not allowlisted or no limit has been explicitly set.
  function getMaxWorkflowsPerDON(
    string calldata donFamily
  ) public view returns (uint32 maxWorkflows) {
    bytes32 donHash = _hash(donFamily);
    return s_donConfigs[donHash].limitValue.value;
  }

  /// @notice Returns the active-workflow cap that applies to a given DON and user.
  /// @dev    If a DON-specific user override is present and enabled, that override value
  ///         is returned; otherwise, the DON’s default limit is used.
  /// @param  user     Address of the user whose override limit is being queried.
  /// @param  donFamily String identifier of the DON.
  /// @return maxActive Maximum number of ACTIVE workflows allowed for the user on that DON.
  function getMaxWorkflowsPerUserDON(address user, string calldata donFamily) public view returns (uint32) {
    bytes32 donHash = _hash(donFamily);
    DonConfig storage cfg = s_donConfigs[donHash];

    // If the user has an override, return that
    ConfigValue memory ov = cfg.userOverride[user];
    if (ov.enabled) {
      return ov.value;
    }

    // Otherwise fall back to the global DON cap
    return cfg.limitValue.value;
  }

  // ================================================================
  // |                         DON registry                         |
  // ================================================================
  /// @notice  Stores the pointer to the DON Registry this Workflow Registry uses.
  /// @dev     `registry` is the contract address; `chainSelector` identifies the
  ///          chain where the registry lives (Chainlink selector).
  struct DONRegistryConfig {
    address registry;
    uint64 chainSelector;
  }

  /// @dev Stores the current DON Registry reference used by this contract.
  DONRegistryConfig private s_donRegistry;

  /// @notice Emitted whenever the registry reference is changed.
  /// @param oldAddr           Previous registry address (zero if first set).
  /// @param newAddr           New registry address being stored.
  /// @param oldChainSelector  Old chain selector (zero if first set).
  /// @param newChainSelector  Chain selector where the registry lives.
  event DONRegistryUpdated(address oldAddr, address newAddr, uint64 oldChainSelector, uint64 newChainSelector);

  /// @notice Sets or replaces the DON Registry that this Workflow Registry points to.
  /// @dev    Owner-only.  Overwrites the previous entry and emits
  ///         {DONRegistryUpdated}.
  /// @param  registry       Address of the DON Registry contract.
  /// @param  chainSelector  Chain selector for the registry’s chain.
  function setDONRegistry(address registry, uint64 chainSelector) external onlyOwner {
    address oldRegistry = s_donRegistry.registry;
    uint64 oldChain = s_donRegistry.chainSelector;

    if (registry == oldRegistry && chainSelector == oldChain) {
      return;
    }

    if (registry != oldRegistry) {
      s_donRegistry.registry = registry;
    }
    if (chainSelector != oldChain) {
      s_donRegistry.chainSelector = chainSelector;
    }

    emit DONRegistryUpdated(oldRegistry, registry, oldChain, chainSelector);
  }

  /// @notice Returns the current DON Registry reference and its chain selector.
  /// @return Address of the DON Registry contract.
  /// @return Chain selector for the registry’s chain.
  function getDONRegistry() external view returns (address, uint64) {
    return (s_donRegistry.registry, s_donRegistry.chainSelector);
  }

  // ================================================================
  // |               Linking Admin Functions                        |
  // ================================================================

  /// @notice Sets the allowed signers for ownership proofs. These signers are considered to be trusted entities.
  /// @param signers The addresses of the signers.
  /// @param allowed The boolean value indicating whether the signer is trusted or not.
  /// @dev Ownership proofs can only be signed by approved group of signers.
  /// When submitting signed proof to this contract, if recovered signature doesn't match any of the signers,
  /// it will be rejected.
  function updateAllowedSigners(address[] calldata signers, bool allowed) external onlyOwner {
    for (uint256 i = 0; i < signers.length; ++i) {
      if (signers[i] == address(0)) {
        revert ZeroAddressNotAllowed();
      }
      s_allowedSigners[signers[i]] = allowed;
    }
    emit AllowedSignersUpdated(signers, allowed);
  }

  /// @notice Returns the allowed signer for ownership proofs.
  /// @param signer The address of the signer.
  /// @return The boolean value indicating whether the signer is allowed to sign ownership proofs or not.
  function isAllowedSigner(
    address signer
  ) external view returns (bool) {
    return s_allowedSigners[signer];
  }

  // ================================================================
  // |                Owner linking functions                       |
  // ================================================================
  /// @notice View function to verify if the linkOwner() function can be called successfully.
  /// @param validityTimestamp Validity of the ownership proof.
  /// @param proof The ownership proof to be submitted.
  /// @param signature The signature of the ownership proof metadata.
  /// @dev This function is used to verify if the ownership proof is valid without actually linking the owner address.
  /// The ownership proof metadata is a combination of the claimed owner address, validity timestamp, and the proof hash.
  /// Request will be rejected if the validity timestamp has expired, owner addres is already linked, if the proof does
  /// not match the one that was originally submitted, or if the signature is not valid (for different reasons).
  /// @dev Verification will use msg.sender as the owner address, which means caller must be the owner of the address,
  /// otherwise the verification will fail with invalid signature error.
  function canLinkOwner(uint256 validityTimestamp, bytes32 proof, bytes calldata signature) public view {
    if (block.timestamp > validityTimestamp) {
      revert LinkOwnerRequestExpired(msg.sender, block.timestamp, validityTimestamp);
    }

    // Workflow owner address may only be linked once
    if (s_linkedOwners.contains(msg.sender)) {
      revert OwnershipLinkAlreadyExists(msg.sender);
    }

    // Ownership proof must be unique and must not be used for linking more than once
    if (s_usedProofs[proof]) {
      revert OwnershipProofAlreadyUsed(msg.sender, proof);
    }

    address signer =
      _recoverSigner(uint8(LinkingRequestType.LINK_OWNER), msg.sender, validityTimestamp, proof, signature);
    if (!s_allowedSigners[signer]) {
      revert InvalidOwnershipLink(msg.sender, validityTimestamp, proof, signature);
    }
  }

  /// @notice Transaction sender submits ownership proof for verification and approval. Upon approval, owner is linked.
  /// @param validityTimestamp Validity of the ownership proof.
  /// @param proof The ownership proof to be submitted.
  /// @param signature The signature of the ownership proof metadata.
  /// @dev Run the verification process first by calling canLinkOwner() function. If the verification does not result
  /// in a revert, then the ownership proof is valid and the owner address can be linked.
  function linkOwner(uint256 validityTimestamp, bytes32 proof, bytes calldata signature) external {
    canLinkOwner(validityTimestamp, proof, signature);

    s_linkedOwners.set(msg.sender, proof);
    s_usedProofs[proof] = true;
    emit OwnershipLinkUpdated(msg.sender, proof, true);
  }

  /// @notice View function to verify if the unlinkOwner() function can be called successfully.
  /// @param owner The address of the owner to be unlinked.
  /// @param validityTimestamp Validity of the ownership proof.
  /// @param signature The signature of the ownership proof metadata.
  /// preUnlinkAction Determines what to do with existing workflows owned by the owner before unlinking.
  /// @dev If preUnlinkAction is NONE, the function will check if there are any active workflows registered to the
  /// owner, and if so, the transaction will revert. If preUnlinkAction is not NONE, then all workflows owned by this
  /// owner's address will be removed or paused before unlinking is completed.
  /// @dev This function is used to verify if the ownership proof is valid without actually unlinking the owner address.
  /// The ownership proof metadata is a combination of the claimed owner address, validity timestamp, and the proof hash.
  /// Request will be rejected if the validity timestamp has expired, owner addres is not linked, if the proof does not
  /// match the one that was originally submitted, or if the signature is not valid (for different reasons).
  /// @dev It is essential to ensure that the unlinking process does not leave any active workflows running because
  /// they can't be managed on the registry by anyone else aside from a valid owner. Without this, the workflows
  /// would be stuck since they can't be managed or removed by anyone.
  /// @dev Important difference between linking and unlinking is that unlinking may be called by any address, as
  /// long as the valid proof is provided. The caller does not have to be the owner of the address being unlinked.
  /// This is done to ensure that unlinking can be done even in cases when access to the private key of the owner
  /// address is lost or compromised, and the owner is not able to submit the unlinking request themselves.
  function canUnlinkOwner(
    address owner,
    uint256 validityTimestamp,
    bytes calldata signature,
    PreUnlinkAction action
  ) public view {
    if ((action == PreUnlinkAction.NONE) && (s_activeOwnerWorkflowRids[owner].length() != 0)) {
      revert CannotUnlinkWithActiveWorkflows();
    }

    if (block.timestamp > validityTimestamp) {
      revert UnlinkOwnerRequestExpired(owner, block.timestamp, validityTimestamp);
    }

    if (!s_linkedOwners.contains(owner)) {
      revert OwnershipLinkDoesNotExist(owner);
    }

    // The expectation is that the signature must contain the same proof that was originally used for the linking
    bytes32 storedProof = s_linkedOwners.get(owner);

    // Request type prevents replay attacks, since the same proof can be used for both linking and unlinking
    address signer =
      _recoverSigner(uint8(LinkingRequestType.UNLINK_OWNER), owner, validityTimestamp, storedProof, signature);
    if (!s_allowedSigners[signer]) {
      revert InvalidOwnershipLink(owner, validityTimestamp, storedProof, signature);
    }
  }

  /// @notice Transaction sender submits ownership proof for verification and approval. Upon approval, owner is unlinked.
  ///         This function can be called by anyone with signatures for the owner.
  /// @param owner The address of the owner to be unlinked.
  /// @param validityTimestamp Validity of the ownership proof.
  /// @param signature The signature of the ownership proof metadata.
  /// preUnlinkAction Determines what to do with existing workflows owned by the owner before unlinking.
  /// @dev If preUnlinkAction is NONE, the function will check if there are any active workflows registered to the
  /// owner, and if so, the transaction will revert. If preUnlinkAction is not NONE, then all workflows owned by this
  /// owner's address will be removed or paused before unlinking is completed.
  /// @dev Run the verification process first by calling canUnlinkOwner() function. If the verification does not result
  /// in a revert, then the ownership proof is valid and the owner address can be unlinked.
  function unlinkOwner(
    address owner,
    uint256 validityTimestamp,
    bytes calldata signature,
    PreUnlinkAction action
  ) external {
    canUnlinkOwner(owner, validityTimestamp, signature, action);

    if (action != PreUnlinkAction.NONE) {
      EnumerableSet.Bytes32Set storage active = s_activeOwnerWorkflowRids[owner];
      // ------------- PAUSE or DELETE -------------
      // Iterate from the back since EnumerableSet.remove() swaps-and-pops.
      while (active.length() > 0) {
        bytes32 rid = active.at(active.length() - 1);
        WorkflowMetadata storage rec = s_workflows[rid];
        if (rec.owner == address(0)) revert WorkflowDoesNotExist();
        if (rec.owner != owner) revert CallerIsNotWorkflowOwner(owner);
        if (action == PreUnlinkAction.PAUSE_WORKFLOWS) {
          _applyPause(rid, rec);
        } else {
          _applyDelete(rid, rec);
        }
      }
    }

    bytes32 storedProof = s_linkedOwners.get(owner);
    s_linkedOwners.remove(owner);
    emit OwnershipLinkUpdated(owner, storedProof, false);
  }

  /// @notice Returns if the owner is linked to this contract.
  /// @param owner The address of the owner.
  /// @return True if the link exists, false otherwise.
  function isOwnerLinked(
    address owner
  ) external view returns (bool) {
    return s_linkedOwners.contains(owner);
  }

  /// @notice Returns total count of linked owners.
  /// @return The total number of linked owners.
  function totalLinkedOwners() external view returns (uint256) {
    return s_linkedOwners.length();
  }

  /// @notice Retrieves a paginated list of addresses that have linked ownership proofs.
  /// @param start Zero-based index of the first owner to include in the result.
  /// @param limit Maximum number of owners to return (clamped by a sensible internal cap).
  /// @return owners An array of owner addresses in the order they were linked.
  /// @dev    - If `start` ≥ total linked owners, returns an empty array.
  ///         - The list can change between calls; for an immutable snapshot, query at a specific block.
  function getLinkedOwners(uint256 start, uint256 limit) external view returns (address[] memory owners) {
    uint256 total = s_linkedOwners.length();
    uint256 count = _getPageCount(total, start, limit);

    owners = new address[](count);
    for (uint256 i = 0; i < count; ++i) {
      (owners[i],) = s_linkedOwners.at(start + i);
    }

    return owners; // solcov:ignore next
  }

  /// @notice Returns the signer of the recovered signature or revert.
  /// @param requestType The type of the request (LINK_OWNER = 0 or UNLINK_OWNER = 1).
  /// @param owner The address of the owner.
  /// @param validityTimestamp The validity timestamp of the ownership proof.
  /// @param proof The ownership proof.
  /// @param signature The signature of the ownership proof metadata.
  /// @return The signer of the recovered signature.
  /// @dev The function tries to re-generate the message digest based on the provided parameters and by following
  /// EIP-191. The it will try to recover the signer address. The function will revert if the signature is invalid.
  function _recoverSigner(
    uint8 requestType,
    address owner,
    uint256 validityTimestamp,
    bytes32 proof,
    bytes calldata signature
  ) internal view returns (address) {
    // Follow EIP-191 for recoverable signatures
    bytes32 prefixedMessageHash = MessageHashUtils.toEthSignedMessageHash(
      keccak256(abi.encode(requestType, owner, block.chainid, address(this), typeAndVersion, validityTimestamp, proof))
    );

    (address signer, ECDSA.RecoverError err, bytes32 errArg) = ECDSA.tryRecover(prefixedMessageHash, signature);
    if (err != ECDSA.RecoverError.NoError) {
      revert InvalidSignature(signature, uint8(err), errArg);
    }

    return signer;
  }

  // ================================================================
  // |                   Capacity Changing Events                   |
  // ================================================================
  enum EventType {
    DONCapacitySet,
    WorkflowAdded,
    WorkflowRemoved
  }

  struct EventRecord {
    EventType eventType;
    uint32 timestamp;
    bytes payload; // ABI‑encoded event data
  }

  // Storage of all capacity and workflow life‑cycle events
  EventRecord[] private s_events;

  /// @notice Returns a page of events along with the total event count.
  /// @param start Zero-based index of the first event to include in the page.
  /// @param limit  Maximum number of events to return in this page.
  /// @return list  Array of events in the requested window.
  function getEvents(uint256 start, uint256 limit) external view returns (EventRecord[] memory list) {
    uint256 total = s_events.length;
    uint256 count = _getPageCount(total, start, limit);

    list = new EventRecord[](count);
    for (uint256 i = 0; i < count; i++) {
      list[i] = s_events[start + i];
    }

    return list; // solcov:ignore next
  }

  /// @notice Returns the total number of capacity- and workflow-lifecycle events ever recorded.
  /// @dev    Use this in tandem with `getEvents(start, limit)` to page through the event stream.
  /// @return count The total count of EventRecord entries stored in `s_events`.
  function totalEvents() external view returns (uint256 count) {
    return s_events.length;
  }

  // ================================================================
  // |                       Workflow Management                    |
  // ================================================================
  /// Storage invariant:
  ///   - `s_workflows` RID is the primary key on the workflow storage.
  /// .   It is comprised of a hash of the (workflowName, workflowOwner, workflowTag)
  ///
  ///   - Every **active** workflow adds to:
  ///         • `s_activeDONWorkflowRids[don]` (all active workflows for a don)
  ///         • `s_activeOwnerWorkflowRids[owner]; (all active workflows for an owner)
  ///         • `s_userDONCount[owner][don]` (all active workflows for an owner in a don)
  ///         • `s_activeRidsByWorkflowKey[key]` (all active workflows by (name, owner))
  ///         • `s_donByWorkflowId[rid]` (the don family that this active workflow is assigned to)
  ///   - Similarly, every deactivation removes from the above indices.
  ///   - Status transitions must update **all five** structures.
  ///
  /// @notice Upserts a new workflow based on workflowName + owner + tag. If triplet already exist
  /// as a record, then we will update that existing workflow. Otherwise, a new one with the new
  /// tag is created.
  /// Status and donFamily cannot be updated via upsert. They must use their own separate functions
  /// for any changes to these workflow fields.
  /// @param workflowName  Human‑readable name (≤64 chars)
  /// @param tag           Unique tag for the workflow (if the same workflowName has been used)
  /// @param workflowId    Deterministic hash computed off‑chain (must be unique)
  /// @param donFamily      Label of the DON
  /// @param status        Initial status (ACTIVE / PAUSED)
  /// @param binaryUrl     URL of the wasm binary (required)
  /// @param configUrl     URL of the config (optional)
  /// @param attributes    Arbitrary bytes for additional workflow details (optional)
  /// @param keepAlive     Boolean flag that determines whether existing workflows with the same
  /// workflowName, workflowOwner combination should be paused or kept active.
  function upsertWorkflow(
    string calldata workflowName,
    string calldata tag,
    bytes32 workflowId,
    WorkflowStatus status,
    string calldata donFamily,
    string calldata binaryUrl,
    string calldata configUrl,
    bytes calldata attributes,
    bool keepAlive
  ) external {
    /* ───────────────────────── 0. VALIDATION ─────────────────────────── */
    // 1) check ownership links
    if (!s_linkedOwners.contains(msg.sender)) {
      revert OwnershipLinkDoesNotExist(msg.sender);
    }
    // 2) check workflowID
    if (workflowId == bytes32(0)) revert ZeroWorkflowIDNotAllowed();
    if (s_idToRid[workflowId] != bytes32(0)) {
      revert WorkflowIDAlreadyExists(workflowId);
    }
    // 3) check URLs (binary url is required. config url is optional; 0 = unlimited)
    uint8 cap = maxUrlLen();
    uint256 binaryLen = bytes(binaryUrl).length;
    uint256 configLen = bytes(configUrl).length;
    if (binaryLen == 0) {
      revert BinaryURLRequired();
    }
    if (cap != 0) {
      if (binaryLen > cap) {
        revert URLTooLong(binaryLen, cap);
      }
      if (configLen > cap) {
        revert URLTooLong(configLen, cap);
      }
    }

    // 4) check attributes (optional; 0 = unlimited)
    uint16 attrCap = maxAttrLen();
    if (attrCap != 0 && attributes.length > attrCap) {
      revert AttributesTooLong(attributes.length, attrCap);
    }

    // 5) check tag (required)
    uint256 tagLen = bytes(tag).length;
    if (tagLen == 0) {
      revert WorkflowTagRequired();
    }
    cap = maxTagLen();
    if (cap != 0 && tagLen > cap) {
      revert WorkflowTagTooLong(tagLen, cap);
    }
    // 6) check workflowName (required)
    uint256 nameLen = bytes(workflowName).length;
    if (nameLen == 0) {
      revert WorkflowNameRequired();
    }
    cap = maxNameLen(); // 0  ➜ unlimited
    if (cap != 0 && nameLen > cap) {
      revert WorkflowNameTooLong(nameLen, cap);
    }

    // using abi.encode here ensures each dynamic field (string) is length-prefixed,
    // so “owner∥name∥tag” can never collide across different triples.
    bytes32 rid = keccak256(abi.encode(msg.sender, workflowName, tag));
    WorkflowMetadata storage rec = s_workflows[rid];
    // Create workflow path
    if (rec.owner == address(0)) {
      bytes32 wKey = _workflowKey(msg.sender, workflowName);
      bytes32 donHash = _hash(donFamily);

      /* ───────────────────────── 1. HOUSEKEEPING ───────────────────────── */
      // we need to do this first, or there may be extra workflows occupying the limit
      if (!keepAlive) {
        EnumerableSet.Bytes32Set storage activeSet = s_activeRidsByWorkflowKey[wKey];
        // Walk from the back since EnumerableSet.remove is a swap and pop.
        while (activeSet.length() > 0) {
          uint256 lastIdx = activeSet.length() - 1;
          bytes32 prevRid = activeSet.at(lastIdx);
          WorkflowMetadata storage prevRec = s_workflows[prevRid];
          // Update workflow state
          _applyPause(prevRid, prevRec);
        }
      }

      /* ───────────────────────── 2. LIMIT CHECKS ───────────────────────── */
      if (status == WorkflowStatus.ACTIVE) {
        _enforceLimits(msg.sender, donHash, donFamily, 1);
        // update indices necessary for active workflows
        _addActiveIndices(rid, msg.sender, donHash, wKey);
      }

      /* ───────────────────────── 3. WRITE PRIMARY RECORD ───────────────── */
      s_workflows[rid] = WorkflowMetadata({
        workflowId: workflowId,
        owner: msg.sender,
        createdAt: uint64(block.timestamp),
        status: status,
        workflowName: workflowName,
        binaryUrl: binaryUrl,
        configUrl: configUrl,
        tag: tag,
        attributes: attributes
      });

      /* ───────────────────────── 4. UPDATE OTHER INDICES ───────────────── */
      s_workflowKeyToRids[wKey].add(rid);
      s_idToRid[workflowId] = rid;
      s_allDONRids[donHash].add(rid);
      s_allOwnerRids[msg.sender].add(rid);

      /* ───────────────────────── 5. EVENT LOG ──────────────────────────── */
      emit WorkflowRegistered(workflowId, msg.sender, donFamily, status, workflowName);
    } else {
      // update workflow path
      // check the workflow belongs to the owner
      if (rec.owner != msg.sender) revert CallerIsNotWorkflowOwner(msg.sender);

      /* ─────── 2. PRIMARY-KEY REMAP ─────── */
      delete s_idToRid[rec.workflowId];
      s_idToRid[workflowId] = rid;

      /* ─────── 3. FIELD PATCHES ─────── */
      bytes32 oldWorkflowId = rec.workflowId;
      rec.workflowId = workflowId;
      if (_hash(rec.binaryUrl) != _hash(binaryUrl)) rec.binaryUrl = binaryUrl;
      if (_hash(rec.configUrl) != _hash(configUrl)) rec.configUrl = configUrl;
      rec.attributes = attributes;

      /* ─────── 4. EVENT ─────── */
      emit WorkflowUpdated(oldWorkflowId, workflowId, msg.sender, donFamily, workflowName);
    }
  }

  function pauseWorkflow(
    bytes32 workflowId
  ) external {
    if (!s_linkedOwners.contains(msg.sender)) {
      revert OwnershipLinkDoesNotExist(msg.sender);
    }

    bytes32 rid = s_idToRid[workflowId];
    WorkflowMetadata storage rec = s_workflows[rid];
    if (rec.owner == address(0)) revert WorkflowDoesNotExist();
    if (rec.owner != msg.sender) revert CallerIsNotWorkflowOwner(msg.sender);
    if (rec.status != WorkflowStatus.PAUSED) {
      _applyPause(rid, rec);
    }
  }

  function activateWorkflow(bytes32 workflowId, string calldata donFamily) external {
    if (!s_linkedOwners.contains(msg.sender)) {
      revert OwnershipLinkDoesNotExist(msg.sender);
    }

    bytes32 rid = s_idToRid[workflowId];
    WorkflowMetadata storage rec = s_workflows[rid];
    if (rec.owner == address(0)) revert WorkflowDoesNotExist();
    if (rec.owner != msg.sender) revert CallerIsNotWorkflowOwner(msg.sender);
    if (rec.status != WorkflowStatus.ACTIVE) {
      bytes32 donHash = _hash(donFamily);
      _enforceLimits(msg.sender, donHash, donFamily, 1);
      _applyActivate(rid, rec, donHash);
    }
  }

  /// @notice Pauses multiple workflows owned by `msg.sender`.
  /// @dev    There is no enforced batch size limit here.
  ///         **User Risk:** Submitting a very large array of `workflowIds`
  ///         may cause the transaction to run out of gas and revert.
  ///         Clients should cap the array length to a safe value based on the current gas limits.
  /// @param  workflowIds Array of workflow IDs to pause; must not be empty.
  function batchPauseWorkflows(
    bytes32[] calldata workflowIds
  ) external {
    uint256 n = workflowIds.length;
    if (n == 0) revert EmptyUpdateBatch();

    if (!s_linkedOwners.contains(msg.sender)) {
      revert OwnershipLinkDoesNotExist(msg.sender);
    }

    for (uint256 i = 0; i < n; ++i) {
      bytes32 rid = s_idToRid[workflowIds[i]];
      WorkflowMetadata storage rec = s_workflows[rid];
      if (rec.owner == address(0)) revert WorkflowDoesNotExist();
      if (rec.owner != msg.sender) revert CallerIsNotWorkflowOwner(msg.sender);
      if (rec.status != WorkflowStatus.PAUSED) {
        _applyPause(rid, rec);
      }
    }
  }

  /// @notice Activate many paused workflows owned by the caller,
  ///        assigning *all* of them to a single DON family.
  ///        If the list contains some workflows that are already ACTIVE on another DON, they are
  ///        silently ignored; the rest are activated on the new DON.
  /// @param workflowIds  Array of workflow IDs to activate (must not be empty).
  /// @param donFamily    Target DON label; must already have a global limit.
  function batchActivateWorkflows(bytes32[] calldata workflowIds, string calldata donFamily) external {
    uint256 n = workflowIds.length;
    if (n == 0) revert EmptyUpdateBatch();
    if (!s_linkedOwners.contains(msg.sender)) {
      revert OwnershipLinkDoesNotExist(msg.sender);
    }

    /* ──────────────────────── 1. PRE‑CHECKS & COUNT ───────────────────── */
    bytes32 donHash = _hash(donFamily);
    uint32 pending = 0; // # workflows that will become ACTIVE

    for (uint256 i; i < n; ++i) {
      bytes32 rid = s_idToRid[workflowIds[i]];
      WorkflowMetadata storage rec = s_workflows[rid];
      if (rec.owner == address(0)) revert WorkflowDoesNotExist();
      if (rec.owner != msg.sender) revert CallerIsNotWorkflowOwner(msg.sender);
      if (rec.status == WorkflowStatus.ACTIVE) continue; // already active, ignore
      ++pending;
    }

    if (pending == 0) return; // nothing to do

    /* ───────────────────────── 2. CAP ENFORCEMENT ─────────────────────── */
    _enforceLimits(msg.sender, donHash, donFamily, pending);

    /* ───────────────────────── 3. STATE MUTATIONS ─────────────────────── */
    for (uint256 i; i < n; ++i) {
      bytes32 rid = s_idToRid[workflowIds[i]];
      WorkflowMetadata storage rec = s_workflows[rid];
      if (rec.status == WorkflowStatus.PAUSED) {
        _applyActivate(rid, rec, donHash); // updates indices & emits WorkflowActivated
      }
    }
  }

  /// @dev   Apply the state transition PAUSED ➜ ACTIVE.
  /// @param rid  Registry-internal reference id (owner ∥ name ∥ tag).
  /// @param rec  Storage pointer to the workflow metadata.
  /// @notice *NO CHECKS* – caller must guarantee
  ///         • `rec.status == WorkflowStatus.PAUSED`
  ///         • DON/user caps have been enforced already.
  ///         • Caller can perform action.
  function _applyActivate(bytes32 rid, WorkflowMetadata storage rec, bytes32 donHash) private {
    _addActiveIndices(rid, rec.owner, donHash, _workflowKey(rec.owner, rec.workflowName));
    rec.status = WorkflowStatus.ACTIVE;

    s_events.push(
      EventRecord({
        eventType: EventType.WorkflowAdded,
        timestamp: uint32(block.timestamp),
        payload: abi.encode(donHash, rec.workflowId)
      })
    );

    emit WorkflowActivated(rec.workflowId, rec.owner, s_donConfigs[donHash].label, rec.workflowName);
  }

  /// @dev   Apply the state transition ACTIVE ➜ PAUSED.
  /// @notice No guards – caller must guarantee that:
  ///         • `rec.status == WorkflowStatus.ACTIVE`
  ///         • Any permission or limit logic has already been handled.
  /// @param  rid   Registry-internal reference ID (owner ∥ name ∥ tag hash).
  /// @param  rec   Storage pointer to the workflow metadata struct.
  function _applyPause(bytes32 rid, WorkflowMetadata storage rec) private {
    rec.status = WorkflowStatus.PAUSED;
    bytes32 donHash = s_donByWorkflowRid[rid];
    _removeActiveIndices(rid, rec.owner, donHash, _workflowKey(rec.owner, rec.workflowName));

    s_events.push(
      EventRecord({
        eventType: EventType.WorkflowRemoved,
        timestamp: uint32(block.timestamp),
        payload: abi.encode(donHash, rec.workflowId)
      })
    );

    emit WorkflowPaused(rec.workflowId, rec.owner, s_donConfigs[donHash].label, rec.workflowName);
  }

  /// @notice Permanently delete a workflow owned by the caller.
  /// @dev Sequence:
  ///  1. Resolve the registry-ID (`rid`) from `workflowId` and verify ownership.
  ///  2. If the workflow is **ACTIVE**, remove it from every
  ///     “active” index and decrement per-DON counters.
  ///  3. Purge the RID from global owner / DON maps and key-based sets.
  ///  4. Clear the ID→RID map, delete the primary record, and emit an event.
  ///  5. Unlinked owners can still delete their workflows.
  ///
  /// @param workflowId  The globally-unique identifier to remove.
  /// @custom:reverts WorkflowDoesNotExist      If the ID is unknown.
  /// @custom:reverts CallerIsNotWorkflowOwner  If `msg.sender` is not the owner.
  function deleteWorkflow(
    bytes32 workflowId
  ) external {
    bytes32 rid = s_idToRid[workflowId];
    WorkflowMetadata storage rec = s_workflows[rid];
    if (rec.owner == address(0)) revert WorkflowDoesNotExist();
    if (rec.owner != msg.sender) revert CallerIsNotWorkflowOwner(msg.sender);
    _applyDelete(rid, rec);
  }

  /// @dev Removes a workflow’s RID from **all “active” indices** and
  ///      decrements the per-user per-DON counter.
  ///
  ///      Caller **must** ensure the workflow is currently
  ///      `WorkflowStatus.ACTIVE`; this helper performs no status
  ///      or validations on its own.
  /// @param rid          Registry-internal reference ID of the workflow.
  /// @param owner        Workflow owner address.
  /// @param donHash      Hash of the DON label of the workflow.
  /// @param workflowKey  keccak256(owner, workflowName) key used for the
  ///                     active-by-name index.
  function _removeActiveIndices(bytes32 rid, address owner, bytes32 donHash, bytes32 workflowKey) private {
    s_activeOwnerWorkflowRids[owner].remove(rid);
    s_activeDONWorkflowRids[donHash].remove(rid);
    s_userDONCount[owner][donHash] -= 1;
    s_activeRidsByWorkflowKey[workflowKey].remove(rid);
    delete s_donByWorkflowRid[rid];
  }

  /// @dev Adds a workflow RID into all “active” indices and increments the per-user, per-DON counter.
  ///      This helper performs no validation on its own.
  /// @param rid          The registry-internal reference ID of the workflow to mark active.
  /// @param owner        The address of the workflow owner.
  /// @param donHash      The keccak256 hash of the DON label under which this workflow is registered.
  /// @param workflowKey  The keccak256(owner, workflowName) key used for name-based active indexing.
  function _addActiveIndices(bytes32 rid, address owner, bytes32 donHash, bytes32 workflowKey) private {
    s_userDONCount[owner][donHash] += 1;
    s_activeDONWorkflowRids[donHash].add(rid);
    s_activeOwnerWorkflowRids[owner].add(rid);
    s_activeRidsByWorkflowKey[workflowKey].add(rid);
    s_donByWorkflowRid[rid] = donHash;
  }

  /// @notice This helper **assumes** all higher-level checks have
  ///         already been performed.
  ///         It also removes the workflow from all active indices.
  /// @param rid  Registry-internal reference ID (hash(owner, name, tag)).
  /// @param rec  Storage pointer to the workflow metadata struct that
  ///             corresponds to `rid`.
  function _applyDelete(bytes32 rid, WorkflowMetadata storage rec) private {
    bytes32 wKey = _workflowKey(rec.owner, rec.workflowName);
    bytes32 donHash = s_donByWorkflowRid[rid];
    string memory donFamily = s_donConfigs[donHash].label;
    if (rec.status == WorkflowStatus.ACTIVE) {
      _removeActiveIndices(rid, rec.owner, donHash, wKey);
    }

    s_allDONRids[donHash].remove(rid);
    s_allOwnerRids[rec.owner].remove(rid);
    s_workflowKeyToRids[wKey].remove(rid);
    delete s_idToRid[rec.workflowId];

    emit WorkflowDeleted(rec.workflowId, rec.owner, donFamily, rec.workflowName);
    delete s_workflows[rid];
  }

  /// @notice Change the DON family for a single workflow, updating all indices. This function only applies
  /// to currently active workflows, as paused workflows do not belong to any DONs and can be set the
  /// DON family upon activation.
  /// @param workflowId   The workflow to reassign
  /// @param newDonFamily The new human‐readable DON family (must be set via setDONLimit)
  function updateWorkflowDONFamily(bytes32 workflowId, string calldata newDonFamily) external {
    if (!s_linkedOwners.contains(msg.sender)) {
      revert OwnershipLinkDoesNotExist(msg.sender);
    }

    bytes32 rid = s_idToRid[workflowId];
    WorkflowMetadata storage rec = s_workflows[rid];
    if (rec.owner == address(0)) revert WorkflowDoesNotExist();
    if (rec.owner != msg.sender) revert CallerIsNotWorkflowOwner(msg.sender);
    if (rec.status != WorkflowStatus.ACTIVE) revert CannotUpdateDONFamilyForPausedWorkflows();

    bytes32 oldDonHash = s_donByWorkflowRid[rid];
    string memory oldDonFamily = s_donConfigs[oldDonHash].label;
    bytes32 newDonHash = _hash(newDonFamily);
    if (oldDonHash == newDonHash) return;

    // remove and pause active indices first for the old don family
    _applyPause(rid, rec);
    _enforceLimits(msg.sender, newDonHash, newDonFamily, 1);
    // activate with the new don Label
    _applyActivate(rid, rec, newDonHash);
    emit WorkflowDonFamilyUpdated(workflowId, msg.sender, oldDonFamily, newDonFamily);
  }

  // ================================================================
  // |                       Admin Workflow                         |
  // ================================================================
  function adminPauseWorkflow(
    bytes32 workflowId
  ) public onlyOwner {
    bytes32 rid = s_idToRid[workflowId];
    WorkflowMetadata storage rec = s_workflows[rid]; // no msg.sender check when fetched directly from mapping
    if (rec.status == WorkflowStatus.ACTIVE) {
      _applyPause(rid, rec);
    }
  }

  // @notice Pauses a batch of workflows as an admin, bypassing workflow ownership checks.
  /// @dev    - Only the contract owner may call this function (enforced by `onlyOwner`).
  ///         - Reverts if `workflowIds` is empty to prevent no-op transactions.
  ///         - Iterates over each provided ID and calls `adminPauseWorkflow`, which itself
  ///           verifies the workflow is active before pausing.
  ///         - Beware: supplying an excessively large array may exhaust gas and revert.
  /// @param  workflowIds  Array of globally-unique workflow IDs to pause; must contain at least one element.
  function adminBatchPauseWorkflows(
    bytes32[] calldata workflowIds
  ) external {
    uint256 n = workflowIds.length;
    if (n == 0) revert EmptyUpdateBatch();

    for (uint256 i; i < n; ++i) {
      adminPauseWorkflow(workflowIds[i]);
    }
  }

  /// @notice Pauses *all* active workflows for a given workflow owner, as an administrator.
  /// @dev    - Only the contract owner may call this (`onlyOwner`).
  ///         - Iterates from the end of the user’s active-workflow set and directly pauses each workflow.
  /// @param  owner The address whose active workflows should be paused.
  function adminPauseAllByOwner(
    address owner
  ) external onlyOwner {
    EnumerableSet.Bytes32Set storage activeSet = s_activeOwnerWorkflowRids[owner];

    // Loop until the set is empty, always pausing the last element. We also know that all workflows in the list are active.
    while (activeSet.length() > 0) {
      bytes32 rid = activeSet.at(activeSet.length() - 1);
      WorkflowMetadata storage rec = s_workflows[rid]; // no msg.sender check when fetched directly from mapping
      _applyPause(rid, rec);
    }
  }

  /// @notice Pauses *all* active workflows under a specific DON label, as an administrator.
  /// @dev    - Only the contract owner may call this (`onlyOwner`).
  ///         - Iterates from the end of the DON’s active-workflow set and directly pauses each workflow.
  /// @param  donFamily The string identifier of the DON whose active workflows should be paused.
  function adminPauseAllByDON(
    string calldata donFamily
  ) external onlyOwner {
    bytes32 donHash = _hash(donFamily);
    EnumerableSet.Bytes32Set storage activeSet = s_activeDONWorkflowRids[donHash];

    // Loop until the set is empty, always pausing the last workflow
    while (activeSet.length() > 0) {
      bytes32 rid = activeSet.at(activeSet.length() - 1);
      WorkflowMetadata storage rec = s_workflows[rid]; // no msg.sender check when fetched directly from mapping
      _applyPause(rid, rec);
    }
  }

  // ================================================================
  // |                       Workflow Views                         |
  // ================================================================
  /// @notice Return the full on-chain metadata for a given workflow.
  /// @dev
  /// 1. Looks up the registry-internal reference‐ID (RID) from
  ///    `s_idToRid` using the caller-supplied `workflowId`.
  /// 2. Uses that RID to fetch the packed `WorkflowMetadata` struct.
  /// 3. Reverts with `WorkflowDoesNotExist` if either mapping slot is
  ///    empty (i.e. the workflow was never registered or has been
  ///    deleted).
  ///
  /// @param workflowId Globally-unique, immutable identifier of the
  ///                   workflow (hash of owner, name, binary, cfg, …).
  /// @return workflow  In-memory copy of the workflow’s metadata record
  /// (it also includes the donFamily string for active workflows).
  ///
  /// @custom:revert WorkflowDoesNotExist  If no RID is found for
  ///                                       `workflowId`, or the RID maps
  ///                                       to an empty metadata record.
  function getWorkflowById(
    bytes32 workflowId
  ) external view returns (WorkflowMetadataView memory workflow) {
    bytes32 rid = s_idToRid[workflowId];
    return _workflowMetadataView(rid);
  }

  /// @notice Return the full on-chain metadata for a given workflow.
  /// @dev
  /// 1. Calculates registry-internal reference‐ID (RID) from
  ///    using the caller-supplied parameters.
  /// 2. Uses that RID to fetch the packed `WorkflowMetadata` struct.
  /// 3. Reverts with `WorkflowDoesNotExist` if either mapping slot is
  ///    empty (i.e. the workflow was never registered or has been
  ///    deleted).
  ///
  /// @param   owner         Address that registered the workflows.
  /// @param   workflowName  Case-sensitive name string (≤ 64 chars).
  /// @param   tag           Unique tag for the workflow.
  /// @return workflow  In-memory copy of the workflow’s metadata record
  /// (it also includes the donFamily string for active workflows).
  ///
  /// @custom:revert WorkflowDoesNotExist  If no RID is found for
  ///                                       `workflowId`, or the RID maps
  ///                                       to an empty metadata record.
  function getWorkflow(
    address owner,
    string calldata workflowName,
    string calldata tag
  ) external view returns (WorkflowMetadataView memory workflow) {
    bytes32 rid = keccak256(abi.encode(owner, workflowName, tag));
    return _workflowMetadataView(rid);
  }

  /// @notice  Return a paginated list of all versions (active *and* paused)
  ///          of workflows with the same `workflowName` and `owner`.
  /// @dev     Uses the secondary key ⟨owner, workflowName⟩ → RID-set
  ///          (`s_workflowKeyToRids`).
  ///          Does **not** revert on out-of-range pagination: if `start` is
  ///          beyond the end of the set the function returns an empty array.
  /// @param   owner         Address that registered the workflows.
  /// @param   workflowName  Case-sensitive name string (≤ 64 chars).
  /// @param   start         Zero-based index into the RID set.
  /// @param   limit         Max #records to return
  /// @return  list          Array of `WorkflowMetadataView`.
  function getWorkflowListByOwnerAndName(
    address owner,
    string calldata workflowName,
    uint256 start,
    uint256 limit
  ) external view returns (WorkflowMetadataView[] memory list) {
    bytes32 wKey = _workflowKey(owner, workflowName);
    uint256 total = s_workflowKeyToRids[wKey].length();
    uint256 count = _getPageCount(total, start, limit);

    list = new WorkflowMetadataView[](count);
    for (uint256 i = 0; i < count; ++i) {
      bytes32 rid = s_workflowKeyToRids[wKey].at(start + i);
      list[i] = _workflowMetadataView(rid);
    }

    return list;
  }

  /// @notice Return a paginated slice of all workflows (active + paused)
  ///         owned by a specific address.
  /// @dev
  /// - Reads the RID set `s_allOwnerRids[owner]`, which contains every
  ///   workflow ever registered by `owner`, regardless of status.
  /// - Does not revert on out-of-range pagination; it simply returns the
  ///   largest sub-range that fits inside the set.
  /// @param owner  The address whose workflows are requested.
  /// @param start  Zero-based index into the owner’s RID set.
  /// @param limit  Batch size for the workflows.
  /// @return list Array of `WorkflowMetadataView` with length
  ///              `min(limit, total-start)`.
  function getWorkflowListByOwner(
    address owner,
    uint256 start,
    uint256 limit
  ) external view returns (WorkflowMetadataView[] memory list) {
    uint256 total = s_allOwnerRids[owner].length();
    uint256 count = _getPageCount(total, start, limit);

    list = new WorkflowMetadataView[](count);
    for (uint256 i = 0; i < count; ++i) {
      bytes32 rid = s_allOwnerRids[owner].at(start + i);
      list[i] = _workflowMetadataView(rid);
    }
    return list;
  }

  /// @notice Fetch a paginated slice of **all** workflows (active *and*
  ///         paused) that belong to a given DON.
  /// @dev
  ///  * Reads the RID set `s_allDONRids[donFamily]`, which tracks every
  ///    workflow ever registered to that DON, regardless of status.
  ///  * If `start` is beyond the set’s length it returns an empty array.
  ///  * Caps `limit` to `MAX_PAGINATION_LIMIT` when the caller supplies
  ///    zero or a value larger than the contract-wide maximum.
  ///  * Does **not** revert on out-of-range requests; instead it returns
  ///    the largest sub-range that fits inside the set.
  ///
  /// @param donFamily  bytes32-encoded DON label used as the secondary key.
  /// @param start     Zero-based index into the RID set.
  /// @param limit     Bathc size for the workflows
  /// @return list     Array of `WorkflowMetadataView` structs whose length is
  ///                  `min(limit, total-start)`.
  function getWorkflowListByDON(
    bytes32 donFamily,
    uint256 start,
    uint256 limit
  ) external view returns (WorkflowMetadataView[] memory list) {
    uint256 total = s_allDONRids[donFamily].length();
    uint256 count = _getPageCount(total, start, limit);

    list = new WorkflowMetadataView[](count);
    for (uint256 i = 0; i < count; ++i) {
      bytes32 rid = s_allDONRids[donFamily].at(start + i);
      list[i] = _workflowMetadataView(rid);
    }

    return list;
  }

  /// @notice Returns the number of ACTIVE workflows on a given DON.
  /// @param donFamily The human-readable DON label (must have been configured via `setDONLimit`).
  /// @return count The total number of active workflows on that DON.
  function totalActiveWorkflowsOnDON(
    string calldata donFamily
  ) external view returns (uint256 count) {
    bytes32 donHash = _hash(donFamily);
    return s_activeDONWorkflowRids[donHash].length();
  }

  /// @notice Returns the number of ACTIVE workflows the owner has over all DONs.
  /// @param owner The owner of the workflows
  /// @return count The total number of active workflows owned by the address in the param.
  function totalActiveWorkflowsByOwner(
    address owner
  ) external view returns (uint256 count) {
    return s_activeOwnerWorkflowRids[owner].length();
  }

  /// @dev Calculates how many items fit into a page slice.
  ///      - If `start >= total`, returns `0` to indicate an empty slice.
  ///      - Otherwise, clamps the page end to `total` when `start + limit` exceeds it.
  /// @param total The total number of items available.
  /// @param start The zero-based index at which the page begins.
  /// @param limit The maximum number of items to include in the page.
  /// @return count The number of items from `start` before hitting `total` (zero if `start >= total`).
  function _getPageCount(uint256 total, uint256 start, uint256 limit) internal pure returns (uint256 count) {
    if (start >= total) {
      return 0;
    }
    uint256 end = start + limit > total ? total : start + limit;
    return end - start;
  }

  function _enforceLimits(address owner, bytes32 donHash, string memory donFamily, uint32 pending) internal view {
    DonConfig storage cfg = s_donConfigs[donHash];
    // Global limit must be explicitly enabled (zero or missing = disallowed)
    if (!cfg.limitValue.enabled) revert DonLimitNotSet(donFamily);

    // Determine the effective cap: start with the global cap, but if this user has an override, use that instead
    uint32 cap = cfg.userOverride[owner].enabled ? cfg.userOverride[owner].value : cfg.limitValue.value;

    // <= to include the pending addition(s)
    if (s_userDONCount[owner][donHash] + pending > cap) {
      revert MaxWorkflowsPerUserDONExceeded(owner, donFamily);
    }
  }

  /// @dev Internal helper that converts a storage record (indexed by RID)
  ///      into an in‑memory `WorkflowMetadataView`.
  function _workflowMetadataView(
    bytes32 rid
  ) internal view returns (WorkflowMetadataView memory v) {
    WorkflowMetadata storage rec = s_workflows[rid];
    if (rec.owner == address(0)) revert WorkflowDoesNotExist();

    // For ACTIVE workflows this will resolve to the correct DON label.
    // For PAUSED/never‑assigned workflows the label is the empty string.
    bytes32 donHash = s_donByWorkflowRid[rid];
    string memory label = s_donConfigs[donHash].label;

    v = WorkflowMetadataView({
      workflowId: rec.workflowId,
      owner: rec.owner,
      createdAt: rec.createdAt,
      status: rec.status,
      workflowName: rec.workflowName,
      binaryUrl: rec.binaryUrl,
      configUrl: rec.configUrl,
      tag: rec.tag,
      attributes: rec.attributes,
      donFamily: label
    });

    return v;
  }

  /// @notice Computes a unique workflow key for indexing by owner and name.
  /// @param owner Address of the workflow owner.
  /// @param name  Human-readable name of the workflow.
  /// @return key  Keccak256 hash combining `owner` and `name`.
  function _workflowKey(address owner, string memory name) internal pure returns (bytes32 key) {
    return keccak256(abi.encode(owner, name));
  }

  /// @notice Hashes an arbitrary-length DON label string into a fixed-size bytes32.
  /// @param str   DON label as a UTF-8 string.
  /// @return hash Keccak256 hash of `bytes(str)`.
  function _hash(
    string memory str
  ) internal pure returns (bytes32 hash) {
    return keccak256(bytes(str));
  }
}
